# -*- coding: utf-8 -*-
"""week 6_ trading algo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ksXkGo2gm4jP5Sibvra_nAs9kSuL6oUg

##initialization:
"""

# !pip install keras-tuner --upgrade

# pip install pykalman

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from tqdm import tqdm

df = pd.read_csv('datasets\Data_cleaned_Dataset.csv', parse_dates=['Trade Date'], index_col='Trade Date')
df.head()

df = df[['Electricity: Wtd Avg Price $/MWh']]

df.interpolate(inplace=True)
df.isna().sum()

mean_non_zero = df[df['Electricity: Wtd Avg Price $/MWh'] != 0]['Electricity: Wtd Avg Price $/MWh'].mean()
df.loc[df['Electricity: Wtd Avg Price $/MWh'] == 0, 'Electricity: Wtd Avg Price $/MWh'] = mean_non_zero
df['Electricity: Wtd Avg Price $/MWh'].min()

df = df.astype('float64')

"""#Predicting the sign:

##using deep learning:
"""

import tensorflow as tf
from tensorflow.keras.models import Sequential
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from keras_tuner import RandomSearch
from tensorflow.keras.optimizers import Adam
from sklearn.model_selection import train_test_split

"""###GRU sign detection"""

from tensorflow.keras.layers import Dense, GRU

# Compute daily returns
df['Returns'] = df['Electricity: Wtd Avg Price $/MWh'].pct_change()
df.dropna(inplace=True)

# Create sequences for GRU model
def create_sequences(data, target, sequence_length):
    xs, ys = [], []
    for i in range(len(data) - sequence_length):
        x = data[i:i + sequence_length]
        y = target[i + sequence_length]
        xs.append(x)
        ys.append(y)
    return np.array(xs), np.array(ys)

# Set sequence length
sequence_length = 14

# Prepare the features and target
X = df[['Electricity: Wtd Avg Price $/MWh']].values
y = df['Returns'].values

# Create sequences
X_seq, y_seq = create_sequences(X, y, sequence_length)

# Convert the target to binary classification: 1 if return is positive, 0 if negative
y_binary = (y_seq > 0).astype(int)

# Split the data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X_seq, y_binary, test_size=0.2, random_state=42)

# Build the GRU model for binary classification
model = Sequential()
model.add(GRU(50, input_shape=(sequence_length, X_train.shape[2]), return_sequences=False))
model.add(Dense(1, activation='sigmoid'))

# Compile the model
model.compile(optimizer=Adam(learning_rate=0.001), loss='binary_crossentropy', metrics=['accuracy'])

# Fit the model
model.fit(X_train, y_train, epochs=50, batch_size=32, validation_split=0.2)

# Evaluate the model
train_score = model.evaluate(X_train, y_train, verbose=0)
test_score = model.evaluate(X_test, y_test, verbose=0)
print(f'Train Score: {train_score}, Test Score: {test_score}')

# Predict
Ptrain = model.predict(X_train)
Ptest = model.predict(X_test)

# Convert predictions to binary
Ptrain_binary = (Ptrain > 0.5).astype(int)
Ptest_binary = (Ptest > 0.5).astype(int)

# Calculate win rate
train_win_rate = np.mean(Ptrain_binary == y_train)
test_win_rate = np.mean(Ptest_binary == y_test)
print(f'Train Win Rate: {train_win_rate * 100:.2f}%, Test Win Rate: {test_win_rate * 100:.2f}%')

# Check if we don't have 0's
print(set(Ptrain_binary.flatten()), set(Ptest_binary.flatten()))

# Create a DataFrame to simulate returns
df_returns = pd.DataFrame({
    'target': df['Returns'].values[sequence_length:],  # Ensure alignment with sequences
    'Position': np.nan
})

# Calculate positions
df_returns['Position'] = 0
df_returns.iloc[:len(Ptrain_binary), df_returns.columns.get_loc('Position')] = Ptrain_binary.flatten()
df_returns.iloc[len(Ptrain_binary):, df_returns.columns.get_loc('Position')] = Ptest_binary.flatten()

# Calculate AlgoReturn
df_returns['AlgoReturn'] = df_returns['Position'] * df_returns['target']

# Calculate cumulative returns
train_algo_return = df_returns.iloc[:len(Ptrain_binary)]['AlgoReturn'].sum() * 100
test_algo_return = df_returns.iloc[len(Ptrain_binary):]['AlgoReturn'].sum() * 100
print(f'Train Algo Return: {train_algo_return:.2f}, Test Algo Return: {test_algo_return:.2f}')

# Calculate Sharpe ratio
daily_return = df_returns['AlgoReturn'].dropna()
sharpe_ratio = daily_return.mean() / daily_return.std() * np.sqrt(252)
print(f'Sharpe Ratio: {sharpe_ratio:.2f}')

df_returns

"""###LSTM sign detection:"""

from tensorflow.keras.layers import LSTM, Dense

df['Returns'] = df['Electricity: Wtd Avg Price $/MWh'].pct_change()
df.dropna(inplace=True)

# Create sequences for LSTM model
def create_sequences(data, target, sequence_length):
    xs, ys = [], []
    for i in range(len(data) - sequence_length):
        x = data[i:i + sequence_length]
        y = target[i + sequence_length]
        xs.append(x)
        ys.append(y)
    return np.array(xs), np.array(ys)

# Set sequence length
sequence_length = 14

# Prepare the features and target
X = df[['Electricity: Wtd Avg Price $/MWh']].values
y = df['Returns'].values

# Create sequences
X_seq, y_seq = create_sequences(X, y, sequence_length)

# Convert the target to binary classification: 1 if return is positive, 0 if negative
y_binary = (y_seq > 0).astype(int)

# Split the data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X_seq, y_binary, test_size=0.2, random_state=42)

# Build the LSTM model for binary classification
model = Sequential()
model.add(LSTM(50, input_shape=(sequence_length, X_train.shape[2]), return_sequences=False))
model.add(Dense(1, activation='sigmoid'))

# Compile the model
model.compile(optimizer=Adam(learning_rate=0.001), loss='binary_crossentropy', metrics=['accuracy'])

# Fit the model
model.fit(X_train, y_train, epochs=50, batch_size=32, validation_split=0.2)

# Evaluate the model
train_score = model.evaluate(X_train, y_train, verbose=0)
test_score = model.evaluate(X_test, y_test, verbose=0)
print(f'Train Score: {train_score}, Test Score: {test_score}')

Ptrain = model.predict(X_train)
Ptest = model.predict(X_test)

# Convert predictions to binary
Ptrain_binary = (Ptrain > 0.5).astype(int)
Ptest_binary = (Ptest > 0.5).astype(int)

# Calculate win rate
train_win_rate = np.mean(Ptrain_binary == y_train)
test_win_rate = np.mean(Ptest_binary == y_test)
print(f'Train Win Rate: {train_win_rate * 100:.2f}%, Test Win Rate: {test_win_rate * 100:.2f}%')

# Check if we don't have 0's
print(set(Ptrain_binary.flatten()), set(Ptest_binary.flatten()))

# Create a DataFrame to simulate returns
df_returns = pd.DataFrame({
    'target': df['Returns'].values[sequence_length:],  # Ensure alignment with sequences
    'Position': np.nan
})

# Calculate positions
df_returns['Position'] = 0
df_returns.iloc[:len(Ptrain_binary), df_returns.columns.get_loc('Position')] = Ptrain_binary.flatten()
df_returns.iloc[len(Ptrain_binary):, df_returns.columns.get_loc('Position')] = Ptest_binary.flatten()

# Calculate AlgoReturn
df_returns['AlgoReturn'] = df_returns['Position'] * df_returns['target']

# Calculate cumulative returns
train_algo_return = df_returns.iloc[:len(Ptrain_binary)]['AlgoReturn'].sum() * 100
test_algo_return = df_returns.iloc[len(Ptrain_binary):]['AlgoReturn'].sum() * 100
print(f'Train Algo Return: {train_algo_return:.2f}, Test Algo Return: {test_algo_return:.2f}')

# Calculate Sharpe ratio
daily_return = df_returns['AlgoReturn'].dropna()
sharpe_ratio = daily_return.mean() / daily_return.std() * np.sqrt(252)
print(f'Sharpe Ratio: {sharpe_ratio:.2f}')

"""##using regression models:

###initialization:
"""

df_returns = pd.DataFrame()

df_returns = np.log(df).diff()

df_returns

df_returns['target']=df_returns.shift(-1)

df_returns.tail()

# Ntest=len(df_returns)*0.20
# print(Ntest)
train=df_returns.iloc[1:-1606]
test=df_returns.iloc[-1606:-1]

train

X_train = train['Electricity: Wtd Avg Price $/MWh'].to_numpy().reshape(-1, 1)
X_test = test['Electricity: Wtd Avg Price $/MWh'].to_numpy().reshape(-1, 1)
y_train = train['target'].to_numpy()
y_test = test['target'].to_numpy()

print(X_train.shape)
print(X_test.shape)

"""###linear regression"""

from sklearn.linear_model import LinearRegression
model=LinearRegression()
model.fit(X_train,y_train)
model.score(X_train,y_train),model.score(X_test,y_test)

Ptrain = model.predict(X_train)
Ptest = model.predict(X_test)
np.mean(np.sign(Ptrain)==np.sign(y_train)),np.mean(np.sign(Ptest)==np.sign(y_test))

"""we have 66.79% winrate"""

set(np.sign(Ptrain)),set(np.sign(Ptest)) #to check we dont have 0's

df_returns['Position'] = 0
df_returns.iloc[1:-1606, df_returns.columns.get_loc('Position')] = (Ptrain > 0)
df_returns.iloc[-1606:-1, df_returns.columns.get_loc('Position')] = (Ptest > 0)

df_returns['AlgoReturn']=df_returns['Position']*df_returns['target']

df_returns.iloc[1:-1606]['AlgoReturn'].sum()*100

df_returns.iloc[-1606:-1]['AlgoReturn'].sum()*100

daily_return = df_returns['AlgoReturn'].dropna()
sharpe_ratio = daily_return.mean() / daily_return.std() * np.sqrt(252)

print(f'Sharpe Ratio: {sharpe_ratio}')

# Plotting
plt.figure(figsize=(12, 6))

# Plotting training data
plt.scatter(X_train, y_train, color='blue', label='Training data')

# Plotting predictions on training data
plt.plot(X_train, Ptrain, color='red', linewidth=2, label='Linear Regression Model')

# Adding labels and title
plt.xlabel('Electricity: Wtd Avg Price $/MWh')
plt.ylabel('Target (Next Day Returns)')
plt.title('Linear Regression Model Prediction vs. Actual (Training Data)')
plt.legend()

# Display plot
plt.show()

"""###random forest"""

Ctrain = (y_train>0)
Ctest = (y_test>0)

Ctest

from sklearn.ensemble import RandomForestClassifier
model=RandomForestClassifier(random_state=1)
model.fit(X_train,Ctrain)
model.score(X_train,Ctrain),model.score(X_test,Ctest)

Ptrain = model.predict(X_train)
Ptest = model.predict(X_test)
np.mean(Ptrain==Ctrain),np.mean(Ptest==Ctest)

df_returns['Position'] = 0
df_returns.iloc[1:-1606, df_returns.columns.get_loc('Position')] = Ptrain
df_returns.iloc[-1606:-1, df_returns.columns.get_loc('Position')] = Ptest

df_returns['AlgoReturn']=df_returns['Position']*df_returns['target']

df_returns.iloc[1:-1606]['AlgoReturn'].sum()*100

df_returns.iloc[-1606:-1]['AlgoReturn'].sum()*100

df_returns

daily_return = df_returns['AlgoReturn'].dropna()
sharpe_ratio = daily_return.mean() / daily_return.std() * np.sqrt(252)

print(f'Sharpe Ratio: {sharpe_ratio}')

"""#Predicting the price:

##Naive forcast
"""

df['Naive Forecast'] = df['Electricity: Wtd Avg Price $/MWh'].shift(1)

# Print the first few rows to see the results
print(df.head())

df['Naive Forecast ROI'] = (df['Electricity: Wtd Avg Price $/MWh'] - df['Naive Forecast']) / df['Naive Forecast']

# Calculate sum of returns
sum_returns = df['Naive Forecast ROI'].sum()

# Print sum of returns and cumulative return
print(f"Sum of Returns: {sum_returns * 100}%")

"""##Random Forest"""

RF_df = pd.read_csv("datasets\Data_cleaned_Dataset.csv")

to_be_dropped = [column for column in RF_df.columns if "Monthly" in column or "Energy Consumption" in column or "End_user" in column or "Energy production" in column]  \
+ ["GDP",
   "UNRATE",
   "Electricity: Delivery Start Date",
   "Electricity: Delivery End Date",
   "Disaster: declaration_date",
   "Disaster: incident_end_date",
   "Electricity: High Price $/MWh",
   "Electricity: Low Price $/MWh",
   "Electricity: Change",
   "Electricity: Daily Volume MWh",
   "Electricity: Number of Trades",
   "Electricity: Number of Companies"]

len(to_be_dropped)

for column in to_be_dropped:
    try:
        RF_df.drop(columns=column, inplace=True)
    except KeyError:
        print(f"Column '{column}' not found in DataFrame. Skipping.")

date_col = [col for col in RF_df.columns if "Date" in col or "date" in col]

date_col

for i in tqdm(range(len(date_col))):
    RF_df[date_col[i]] = pd.to_datetime(RF_df[date_col[i]])

RF_df["Disaster: state"].unique()

RF_df['Natural Gas: Henry Hub Natural Gas Spot Price (Dollars per Million Btu)'] = RF_df['Natural Gas: Henry Hub Natural Gas Spot Price (Dollars per Million Btu)'].shift(1)
RF_df['pjm_load sum in MW (daily)'] = RF_df['pjm_load sum in MW (daily)'].shift(1)

RF_df=RF_df.loc[RF_df['Trade Date'] <= '2018-08-02']

RF_df.interpolate(inplace=True)

RF_df=RF_df.iloc[1:]
RF_df

def show_nonzero_nans(df):
    """
    This function displays the columns in the DataFrame that have non-zero missing values.
    """
    nan_counts = df.isna().sum()
    nonzero_nans = nan_counts[nan_counts > 0]

    if not nonzero_nans.empty:
        print(nonzero_nans)
    else:
        print("No columns with NaN values.")

show_nonzero_nans(RF_df)

mean_non_zero = df[df['Electricity: Wtd Avg Price $/MWh'] != 0]['Electricity: Wtd Avg Price $/MWh'].mean()
df.loc[df['Electricity: Wtd Avg Price $/MWh'] == 0, 'Electricity: Wtd Avg Price $/MWh'] = mean_non_zero
df['Electricity: Wtd Avg Price $/MWh'].min()

RF_df['Disaster: state'] = pd.factorize(RF_df['Disaster: state'])[0] + 1
RF_df['Disaster: incident_type'] = pd.factorize(RF_df['Disaster: incident_type'])[0] + 1
RF_df["Weekday"] = pd.factorize(RF_df['Weekday'])[0]

RF_df["Disaster: incident_type"].unique()

X = RF_df.drop(columns=["Electricity: Wtd Avg Price $/MWh", "Trade Date"])
X.insert(0, "Day", RF_df["Trade Date"].dt.day)
X.insert(1, "Month", RF_df["Trade Date"].dt.month)
X.insert(2, "Year", RF_df["Trade Date"].dt.year)

y = RF_df["Electricity: Wtd Avg Price $/MWh"]

from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
from sklearn.ensemble import RandomForestRegressor

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

regr = RandomForestRegressor(n_jobs=-1, max_depth=2, random_state=42)

regr.fit(X_train, y_train)

# Create evaluation function (the competition uses RMSLE)
from sklearn.metrics import mean_absolute_error, r2_score, mean_squared_error

def rmse(y_test, y_preds):
    """
    Caculates root mean squared log error between predictions and
    true labels.
    """
    return np.sqrt(mean_squared_error(y_test, y_preds))

# Create function to evaluate model on a few different levels
def show_scores(model, X_train, X_valid, y_train, y_valid):
    train_preds = model.predict(X_train)
    val_preds = model.predict(X_valid)
    scores = {"Training MAE": mean_absolute_error(y_train, train_preds),
              "Valid MAE": mean_absolute_error(y_valid, val_preds),
              "Training MSE": mean_squared_error(y_train, train_preds),
              "Valid MSE": mean_squared_error(y_valid, val_preds),
              "Training RMSE": rmse(y_train, train_preds),
              "Valid RMSE": rmse(y_valid, val_preds),
              "Training R^2": r2_score(y_train, train_preds),
              "Valid R^2": r2_score(y_valid, val_preds)}
    return scores

show_scores(regr, X_train, X_test, y_train, y_test)

# Different RandomForestRegressor hyperparameters
rf_grid = {
    "n_estimators": np.arange(10, 100, 10),
    "max_depth": [None, 3, 5, 10],
    "min_samples_split": np.arange(2, 20, 2),
    "min_samples_leaf": np.arange(1, 20, 2),
    "max_features": [0.5, 1, "sqrt"],
    "max_samples": [4000]
}

# Perform GridSearchCV
regr_GRID = GridSearchCV(RandomForestRegressor(n_jobs=-1), rf_grid)
regr_GRID.fit(X_train, y_train)

# Get the best parameters
best_params = regr_GRID.best_params_

# Train the ideal model with best parameters
ideal_model = RandomForestRegressor(
    n_estimators=best_params['n_estimators'],
    min_samples_leaf=best_params['min_samples_leaf'],
    min_samples_split=best_params['min_samples_split'],
    max_features=best_params['max_features'],
    n_jobs=-1,
    max_samples=best_params['max_samples'],
    random_state=42
)

ideal_model.fit(X_train, y_train)

# Function to show scores (assuming it's defined elsewhere)
show_scores(ideal_model, X_train, X_test, y_train, y_test)

# Plot feature importances
def plot_features(columns, importances):
    df = (pd.DataFrame({"features": columns, "feature_importances": importances})
          .sort_values("feature_importances", ascending=False)
          .reset_index(drop=True))

    fig, ax = plt.subplots(figsize=(10, 0.3 * len(df)))
    ax.barh(df["features"], df["feature_importances"])
    ax.set_ylabel("Features")
    ax.set_xlabel("Feature importance")
    ax.invert_yaxis()
    plt.show()

plot_features(X_train.columns, ideal_model.feature_importances_)

"""Next-Day Prediction with RandomForestRegressor"""

test_size = int(len(df) * 0.2)
train_data = df[:-test_size]
test_data = df[-test_size:]

predictions = []

for t in range(len(test_data)):
    # Define the features and target for training
    X_train = train_data.drop(columns='Electricity: Wtd Avg Price $/MWh')
    y_train = train_data['Electricity: Wtd Avg Price $/MWh']

    # Fit the model
    ideal_model.fit(X_train, y_train)

    # Predict the next day
    X_test = test_data.drop(columns='Electricity: Wtd Avg Price $/MWh').iloc[t:t+1]  # Single row for prediction
    predicted_value = ideal_model.predict(X_test)[0]

    predictions.append(predicted_value)

    # Update training data with the new observed value
    train_data = pd.concat([train_data, test_data.iloc[t:t+1]])

predictions_series = pd.Series(predictions, index=test_data.index)

plt.plot(df.index[-test_size:], df.loc[df.index[-test_size:]], label='Observed')
plt.plot(predictions_series.index, predictions_series, color='r', label='Forecast')
plt.xlabel('Date')
plt.ylabel('Electricity Price - USD')
plt.legend()
plt.title('RandomForest Next-Day Predictions')
plt.show()

"""Trading Part:"""

# Prepare the data for trading algorithm
data = pd.DataFrame({
    'X_test': test_data['target_column'].shift(1),  # Shifted to align with previous day's actual value
    'y_test': test_data['target_column'],
    'predictions': predictions
})

# Fill the first value of X_test with the last value of the train_data target column
data['X_test'].iloc[0] = train_data['target_column'].iloc[-1]

data['position'] = 0
data.loc[data['X_test'] < data['predictions'], 'position'] = 1
data.loc[data['X_test'] > data['predictions'], 'position'] = -1

data['returns'] = None
data['correct'] = None

# Evaluate trading positions
for i in range(len(data)):
    row_index = data.index[i]

    if data['position'][row_index] == 1:
        if data['X_test'][row_index] < data['y_test'][row_index]:
            data.at[row_index, 'correct'] = 1 if data['y_test'][row_index] > data['predictions'][row_index] else 0
        else:
            data.at[row_index, 'correct'] = -1

    elif data['position'][row_index] == -1:
        if data['X_test'][row_index] > data['y_test'][row_index]:
            data.at[row_index, 'correct'] = 1 if data['y_test'][row_index] < data['predictions'][row_index] else 0
        else:
            data.at[row_index, 'correct'] = -1

# Calculate returns
for index in data.index:
    if data.loc[index, 'correct'] == 1:
        data.loc[index, 'returns'] = abs((data.loc[index, 'predictions'] - data.loc[index, 'X_test']) / data.loc[index, 'X_test'])
    elif data.loc[index, 'correct'] == 0:
        data.loc[index, 'returns'] = abs((data.loc[index, 'y_test'] - data.loc[index, 'X_test']) / data.loc[index, 'X_test'])
    elif data.loc[index, 'correct'] == -1:
        data.loc[index, 'returns'] = abs((data.loc[index, 'y_test'] - data.loc[index, 'X_test']) / data.loc[index, 'X_test']) * (-1)

winrate = len(data[data["correct"].isin([1, 0])]) / len(data) * 100
roi = data["returns"].sum() * 100

print(f'Winrate for RandomForest is: {winrate}%')
print(f'The ROI for RandomForest is: {roi}%')

plt.plot(data['returns'].iloc[0:500], label='Returns')
plt.plot(data['returns'].iloc[0:500].cumsum(), label='Cumulative Returns')
plt.legend()
plt.show()

"""##machine learning models:"""

#!pip install arch numpy pandas scipy scikit-learn statsmodels

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.stats.diagnostic import acorr_ljungbox
import statsmodels.api as sm
from arch import arch_model
from scipy.stats import norm
from sklearn.metrics import mean_absolute_error, mean_squared_error
from sklearn.model_selection import train_test_split
from pykalman import KalmanFilter
from keras_tuner import RandomSearch
from statsmodels.tsa.stattools import adfuller

df.index = pd.to_datetime(df.index)
df = df.asfreq('D')

def adf(x):
  res=adfuller(x)
  print("Test-Statistic:",res[0])
  print("P-Value:",res[1])
  if res[1]<0.05:
    print("Stationary")
  else:
    print("NON_Stationary")

adf(df['Electricity: Wtd Avg Price $/MWh'])

# Create figure
fig, (ax1, ax2) = plt.subplots(2,1, figsize=(12,8))

# Plot the ACF of df
plot_acf(df, lags=10, zero=False, ax=ax1)

# Plot the PACF of df
plot_pacf(df, lags=10, zero=False, ax=ax2)

plt.show()

#!pip install pmdarima
from pmdarima import auto_arima

"""###ARIMA"""

from statsmodels.tsa.arima.model import ARIMA

test_size=int(len(df)*0.2)

results_list = []

for p in [1]:
    for q in [1,2,3]:
        for i in [0]:
            try:
                # Split data into training and validation sets
                train_data = df[:-test_size]
                test_data = df[-test_size:]

                predictions = []

                for t in range(len(test_data)):
                    model = ARIMA(train_data, order=(p, i, q))
                    results = model.fit()

                    # Forecast the next day
                    forecast = results.forecast(steps=1)[0]

                    predictions.append(forecast)

                    # Update training data with the new observed value
                    train_data = pd.concat([train_data, test_data.iloc[t:t+1]])

                actual_values = test_data.values
                print(predictions)
                # Calculate RMSE
                rmse = np.sqrt(np.mean((np.array(predictions) - actual_values)**2))

                # Calculate MAE
                mae = np.mean(np.abs(np.array(predictions) - actual_values))

                results_list.append((p, i, q, results.aic, results.bic, rmse, mae))

            except Exception as e:
                print(f"Error with parameters p={p}, i={i}, q={q}: {e}")
                results_list.append((p, i, q, None, None, None, None, str(e)))

# Display results
for result in results_list:
    print(result)

results_list

# Convert the results to a DataFrame for better readability
results_df = pd.DataFrame(results_list, columns=['p','i','q', 'AIC', 'BIC','RMSE','MAE'])

# Display the results
print(results_df.sort_values(by='AIC'))
print(results_df.sort_values(by='BIC'))
print(results_df.sort_values(by='RMSE'))

# Applying the best found model
last_n_days = df.index[-test_size:]

for p, i, q in [(7, 1, 1)]:
    try:
        train_data = df[:-test_size]
        test_data = df[-test_size:]

        predictions = []
        lower_limits = []
        upper_limits = []

        for t in range(len(test_data)):
            model = ARIMA(train_data, order=(p, i, q))
            results = model.fit()

            # Forecast the next day
            forecast = results.get_forecast(steps=1)
            predicted_value = forecast.predicted_mean[0]
            predictions.append(predicted_value)

            # Get confidence intervals of predictions
            conf_int = forecast.conf_int(alpha=0.05)
            lower_limits.append(conf_int.iloc[0, 0])
            upper_limits.append(conf_int.iloc[0, 1])

            # Update training data with the new observed value
            train_data = pd.concat([train_data, test_data.iloc[t:t+1]])

        # Convert predictions to a pandas Series
        predictions_series = pd.Series(predictions, index=test_data.index)
        lower_limits_series = pd.Series(lower_limits, index=test_data.index)
        upper_limits_series = pd.Series(upper_limits, index=test_data.index)

        # Plot the last n days of df data
        plt.plot(last_n_days, df.loc[last_n_days], label='observed')

        # Plot the predictions for the test period
        plt.plot(predictions_series.index, predictions_series, color='r', label='forecast')

        # Shade the area between your confidence limits for the test period
        plt.fill_between(predictions_series.index, lower_limits_series, upper_limits_series, color='pink')

        # Set labels, legends, and show plot
        plt.xlabel('Date')
        plt.ylabel(f'Electricity Price - USD for p:{p}, i:{i}, q:{q}')
        plt.legend()
        plt.title(f'ARIMA ({p}, {i}, {q}) Forecast and Confidence Intervals')
        plt.show()

    except Exception as e:
        print(f'ARIMA ({p}, {i}, {q}) encountered an error: {str(e)}')

"""####Trading ALGO:"""

# Convert test_data to a Series (1-dimensional) before creating the DataFrame
data = pd.DataFrame({'X_test': test_data.squeeze().shift(1),'y_test': test_data.squeeze(), 'predictions': predictions})
data['X_test'][0]=train_data['Electricity: Wtd Avg Price $/MWh'].iloc[-1]

data

data['position'] = 0
for i in range(len(data)):
    if data['X_test'][i] < data['predictions'][i]:
      data['position'][i] = 1
    elif data['X_test'][i] > data['predictions'][i]:
      data['position'][i] = -1
    else:
      data['position'][i] = 0

data

# Initialize the 'returns' and 'correct' columns
data['returns'] = None
data['correct'] = None

# Main loop to calculate 'correct' values
for i in range(len(data)):
    row_index = data.index[i]  # Get the actual index label for the current row

    if data['position'][row_index] == 1:  # Long position
        if data['X_test'][row_index] < data['y_test'][row_index]:  # Market went up
            if data['y_test'][row_index] > data['predictions'][row_index]:
                data.at[row_index, 'correct'] = 1  # Prediction lower than actual
            else:
                data.at[row_index, 'correct'] = 0  # Prediction higher than actual
        else:
            data.at[row_index, 'correct'] = -1  # Market went down, wrong position

    elif data['position'][row_index] == -1:  # Short position
        if data['X_test'][row_index] > data['y_test'][row_index]:  # Market went down
            if data['y_test'][row_index] < data['predictions'][row_index]:
                data.at[row_index, 'correct'] = 1  # Prediction higher than actual
            else:
                data.at[row_index, 'correct'] = 0  # Prediction lower than actual
        else:
            data.at[row_index, 'correct'] = -1  # Market went up, wrong position

# Iterate over the actual index of the DataFrame for returns calculation
for index in data.index:
    if data.loc[index, 'correct'] == 1:
        data.loc[index, 'returns'] = abs((data.loc[index, 'predictions'] - data.loc[index, 'X_test']) / data.loc[index, 'X_test'])
    elif data.loc[index, 'correct'] == 0:
        data.loc[index, 'returns'] = abs((data.loc[index, 'y_test'] - data.loc[index, 'X_test']) / data.loc[index, 'X_test'])
    elif data.loc[index, 'correct'] == -1:
        data.loc[index, 'returns'] = abs((data.loc[index, 'y_test'] - data.loc[index, 'X_test']) / data.loc[index, 'X_test']) * (-1)

data

print(f'winrate for GRU is: {len(data[data["correct"].isin([1,0])])/int(len(data))*100}%')

print(f'the ROI for GRU is: {data["returns"].sum()*100}%')

plt.plot(data['returns'].iloc[0:500], label='Returns') # Add label for returns
plt.plot(data['returns'].iloc[0:500].cumsum(), label='Cumulative Returns') # Add label for cumulative returns
plt.legend() # Display the legend
plt.show()

"""###SARIMA"""

from statsmodels.tsa.statespace.sarimax import SARIMAX

seasonality=7

test_size = int(len(df) * 0.2)

results_list = []

# Loop over SARIMA parameters
for p in [1]:
    for d in [0, 1]:
        for q in [1, 2, 3]:
            for P in [0, 1]:
                for D in [0, 1]:
                    for Q in [0, 1, 2]:
                        try:
                            # Split data into training and validation sets
                            train_data = df[:-test_size]
                            test_data = df[-test_size:]

                            predictions = []

                            for t in range(len(test_data)):
                                model = SARIMAX(train_data, order=(p, d, q), seasonal_order=(P, D, Q, seasonality))
                                results = model.fit(disp=False)

                                # Forecast the next day
                                forecast = results.get_forecast(steps=1)
                                predicted_value = forecast.predicted_mean[0]

                                predictions.append(predicted_value)

                                # Update training data with the new observed value
                                train_data = pd.concat([train_data, test_data.iloc[t:t+1]])

                            actual_values = test_data.values
                            # Calculate RMSE
                            rmse = np.sqrt(np.mean((np.array(predictions) - actual_values) ** 2))

                            # Calculate MAE
                            mae = np.mean(np.abs(np.array(predictions) - actual_values))

                            results_list.append((p, d, q, P, D, Q, results.aic, results.bic, rmse, mae))

                        except Exception as e:
                            print(f"Error with parameters p={p}, d={d}, q={q}, P={P}, D={D}, Q={Q}: {e}")
                            results_list.append((p, d, q, P, D, Q, None, None, None, None, str(e)))

# Display results
for result in results_list:
    print(result)

results_list

# Convert the results to a DataFrame for better readability
results_df = pd.DataFrame(results_list, columns=['p', 'd', 'q', 'P', 'D', 'Q', 'AIC', 'BIC', 'RMSE', 'MAE','temp'])

# Display the results
print(results_df.sort_values(by='AIC'))
print(results_df.sort_values(by='BIC'))
print(results_df.sort_values(by='RMSE'))

# Applying the best found model

for p, d, q, P, D, Q in [(2, 1, 2, 1, 0, 2)]:
    try:
        train_data = df[:-test_size]
        test_data = df[-test_size:]

        predictions = []
        lower_limits = []
        upper_limits = []

        for t in range(len(test_data)):
            model = SARIMAX(train_data, order=(p, d, q), seasonal_order=(P, D, Q, seasonality),suppress_warnings=True)
            results = model.fit(disp=False)

            # Forecast the next day
            forecast = results.get_forecast(steps=1)
            predicted_value = forecast.predicted_mean[0]
            predictions.append(predicted_value)

            # Get confidence intervals of predictions
            conf_int = forecast.conf_int(alpha=0.05)
            lower_limits.append(conf_int.iloc[0, 0])
            upper_limits.append(conf_int.iloc[0, 1])

            # Update training data with the new observed value
            train_data = pd.concat([train_data, test_data.iloc[t:t+1]])

        # Convert predictions to a pandas Series
        predictions_series = pd.Series(predictions, index=test_data.index)
        lower_limits_series = pd.Series(lower_limits, index=test_data.index)
        upper_limits_series = pd.Series(upper_limits, index=test_data.index)

        # Plot the last n days of df data
        plt.plot(df.index[-test_size:], df.loc[df.index[-test_size:]], label='observed')

        # Plot the predictions for the test period
        plt.plot(predictions_series.index, predictions_series, color='r', label='forecast')

        # Shade the area between your confidence limits for the test period
        plt.fill_between(predictions_series.index, lower_limits_series, upper_limits_series, color='pink')

        # Set labels, legends, and show plot
        plt.xlabel('Date')
        plt.ylabel(f'Electricity Price - USD for p:{p}, d:{d}, q:{q}, P:{P}, D:{D}, Q:{Q}')
        plt.legend()
        plt.title(f'SARIMA ({p}, {d}, {q}) x ({P}, {D}, {Q}, {seasonality}) Forecast and Confidence Intervals')
        plt.show()

    except Exception as e:
        print(f'SARIMA ({p}, d, {q}, {P}, {D}, {Q}) encountered an error: {str(e)}')

"""####Trading ALGO:"""

# Convert test_data to a Series (1-dimensional) before creating the DataFrame
data = pd.DataFrame({'X_test': test_data.squeeze().shift(1),'y_test': test_data.squeeze(), 'predictions': predictions})
data['X_test'][0]=train_data['Electricity: Wtd Avg Price $/MWh'].iloc[-1]

data

data['position'] = 0
for i in range(len(data)):
    if data['X_test'][i] < data['predictions'][i]:
      data['position'][i] = 1
    elif data['X_test'][i] > data['predictions'][i]:
      data['position'][i] = -1
    else:
      data['position'][i] = 0

data

# Initialize the 'returns' and 'correct' columns
data['returns'] = None
data['correct'] = None

# Main loop to calculate 'correct' values
for i in range(len(data)):
    row_index = data.index[i]  # Get the actual index label for the current row

    if data['position'][row_index] == 1:  # Long position
        if data['X_test'][row_index] < data['y_test'][row_index]:  # Market went up
            if data['y_test'][row_index] > data['predictions'][row_index]:
                data.at[row_index, 'correct'] = 1  # Prediction lower than actual
            else:
                data.at[row_index, 'correct'] = 0  # Prediction higher than actual
        else:
            data.at[row_index, 'correct'] = -1  # Market went down, wrong position

    elif data['position'][row_index] == -1:  # Short position
        if data['X_test'][row_index] > data['y_test'][row_index]:  # Market went down
            if data['y_test'][row_index] < data['predictions'][row_index]:
                data.at[row_index, 'correct'] = 1  # Prediction higher than actual
            else:
                data.at[row_index, 'correct'] = 0  # Prediction lower than actual
        else:
            data.at[row_index, 'correct'] = -1  # Market went up, wrong position

# Iterate over the actual index of the DataFrame for returns calculation
for index in data.index:
    if data.loc[index, 'correct'] == 1:
        data.loc[index, 'returns'] = abs((data.loc[index, 'predictions'] - data.loc[index, 'X_test']) / data.loc[index, 'X_test'])
    elif data.loc[index, 'correct'] == 0:
        data.loc[index, 'returns'] = abs((data.loc[index, 'y_test'] - data.loc[index, 'X_test']) / data.loc[index, 'X_test'])
    elif data.loc[index, 'correct'] == -1:
        data.loc[index, 'returns'] = abs((data.loc[index, 'y_test'] - data.loc[index, 'X_test']) / data.loc[index, 'X_test']) * (-1)

data

print(f'winrate for SARIMA is: {len(data[data["correct"].isin([1,0])])/int(len(data))*100}%')

print(f'the ROI for SARIMA is: {data["returns"].sum()*100}%')

plt.plot(data['returns'].iloc[0:500], label='Returns') # Add label for returns
plt.plot(data['returns'].iloc[0:500].cumsum(), label='Cumulative Returns') # Add label for cumulative returns
plt.legend() # Display the legend
plt.show()

"""###Auto arima (SARIMA)"""

test_size = int(len(df) * 0.2)
print(test_size)
train_data = df[:-test_size]
test_data = df[-test_size:]

# Fit auto_arima model
auto_model = auto_arima(train_data, seasonal=True, m=seasonality, trace=True, error_action='ignore', suppress_warnings=True, stepwise=True)

# Summarize the model
print(auto_model.summary())

# Use the fitted model to make predictions
predictions = []
lower_limits = []
upper_limits = []

for t in range(len(test_data)):
    model = auto_model.fit(train_data)

    # Forecast the next day
    forecast, conf_int = model.predict(n_periods=1, return_conf_int=True)
    predicted_value = forecast[0]
    predictions.append(predicted_value)

    # Get confidence intervals of predictions
    lower_limits.append(conf_int[0][0])
    upper_limits.append(conf_int[0][1])

    # Update training data with the new observed value
    train_data = pd.concat([train_data, test_data.iloc[t:t+1]])

# Calculate RMSE and MAE
actual_values = test_data.values
rmse = np.sqrt(mean_squared_error(actual_values, predictions))
mae = mean_absolute_error(actual_values, predictions)

print(f"RMSE: {rmse}")
print(f"MAE: {mae}")

# Convert predictions to a pandas Series
predictions_series = pd.Series(predictions, index=test_data.index)
lower_limits_series = pd.Series(lower_limits, index=test_data.index)
upper_limits_series = pd.Series(upper_limits, index=test_data.index)

# Plot the last n days of df data
last_n_days = df.index[-test_size:]

plt.plot(last_n_days, df.loc[last_n_days], label='Observed')

# Plot the predictions for the test period
plt.plot(predictions_series.index, predictions_series, color='r', label='Forecast')

# Shade the area between your confidence limits for the test period
plt.fill_between(predictions_series.index, lower_limits_series, upper_limits_series, color='pink')

# Set labels, legends, and show plot
plt.xlabel('Date')
plt.ylabel('Electricity Price - USD')
plt.legend()
plt.title('Auto ARIMA Forecast and Confidence Intervals')
plt.show()

# Trading algorithm

# Convert test_data to a Series (1-dimensional) before creating the DataFrame
data = pd.DataFrame({'X_test': test_data.squeeze().shift(1), 'y_test': test_data.squeeze(), 'predictions': predictions})
data['X_test'].iloc[0] = train_data.iloc[-1]

# Initialize position column
data['position'] = None
for i in range(len(data)):
    if data['X_test'].iloc[i] < data['predictions'].iloc[i]:
        data['position'].iloc[i] = 1  # Long
    elif data['X_test'].iloc[i] > data['predictions'].iloc[i]:
        data['position'].iloc[i] = -1  # Short

# Initialize returns and correct columns
data['returns'] = None
data['correct'] = None

# Calculate returns and correctness of positions
for i in range(len(data)):
    if data['position'].iloc[i] == 1:  # Long position
        if data['X_test'].iloc[i] < data['y_test'].iloc[i]:  # Market went up
            if data['y_test'].iloc[i] > data['predictions'].iloc[i]:
                data['correct'].iloc[i] = 1  # Prediction lower than actual
            else:
                data['correct'].iloc[i] = 0  # Prediction higher than actual
        else:
            data['correct'].iloc[i] = -1  # Market went down, wrong position

    elif data['position'].iloc[i] == -1:  # Short position
        if data['X_test'].iloc[i] > data['y_test'].iloc[i]:  # Market went down
            if data['y_test'].iloc[i] < data['predictions'].iloc[i]:
                data['correct'].iloc[i] = 1  # Prediction higher than actual
            else:
                data['correct'].iloc[i] = 0  # Prediction lower than actual
        else:
            data['correct'].iloc[i] = -1  # Market went up, wrong position

# Calculate returns based on correctness
for i in range(len(data)):
    if data['correct'].iloc[i] == 1:
        data['returns'].iloc[i] = abs((data['predictions'].iloc[i] - data['X_test'].iloc[i]) / data['X_test'].iloc[i])
    elif data['correct'].iloc[i] == 0:
        data['returns'].iloc[i] = abs((data['y_test'].iloc[i] - data['X_test'].iloc[i]) / data['X_test'].iloc[i])
    elif data['correct'].iloc[i] == -1:
        data['returns'].iloc[i] = abs((data['y_test'].iloc[i] - data['X_test'].iloc[i]) / data['X_test'].iloc[i]) * -1

# Calculate winrate and ROI
winrate = len(data[data['correct'].isin([1, 0])]) / len(data) * 100
roi = data['returns'].sum() * 100

print(f'the Winrate of the Auto ARIMA is: {winrate}%')
print(f'the ROI for the Auto ARIMA is: {roi}%')

# Plot returns and cumulative returns
plt.plot(data['returns'].iloc[:500], label='Returns')  # Add label for returns
plt.plot(data['returns'].iloc[:500].cumsum(), label='Cumulative Returns')  # Add label for cumulative returns
plt.legend()  # Display the legend
plt.show()

"""###Garch

i will use log prices instead of prices
"""

df['log_return'] = np.log(df['Electricity: Wtd Avg Price $/MWh'] / df['Electricity: Wtd Avg Price $/MWh'].shift(1))
df = df.replace([np.inf, -np.inf], np.nan).fillna(df['log_return'].mean())

df = df.rolling(window=52).mean()

dfstd = df.rolling(window=52).std()

df['upper'] = df['Electricity: Wtd Avg Price $/MWh'] + (2 * dfstd['Electricity: Wtd Avg Price $/MWh'])

df['lower'] = df['Electricity: Wtd Avg Price $/MWh'] - (2 * dfstd['Electricity: Wtd Avg Price $/MWh'])

ax = df.plot(linewidth=0.8, fontsize=6)

ax.set_xlabel('Date', fontsize=10)
ax.set_ylabel('Electricity levels in PJM', fontsize=10)
ax.set_title('Rolling mean and variance of Electricity levels in PJM', fontsize=10)
plt.show()

df['log_return'].hist(bins=100)
plt.title('Electricity returns')
plt.show()

# Plot ACF
plt.figure(figsize=(12, 6))
plot_acf(train, lags=30, alpha=0.05)
plt.xlabel('Lags')
plt.ylabel('Autocorrelation')
plt.title('ACF of Electricity Log Returns')
plt.show()

# Plot PACF
plt.figure(figsize=(12, 6))
plot_pacf(train, lags=30, alpha=0.05)
plt.xlabel('Lags')
plt.ylabel('Partial Autocorrelation')
plt.title('PACF of Electricity Log Returns')
plt.show()

df['log_return_scaled'] = df['log_return'] * 10

test_size = int(len(df)*0.2)
train = df['log_return_scaled'].dropna()[:-test_size]
test = df['log_return_scaled'].dropna()[-test_size:]

# Hyperparameter tuning
best_aic = np.inf
best_bic = np.inf
best_mae = np.inf
best_params = None
results = []

# Parameters to test
p_values = [1, 2, 3]
q_values = [1, 2, 3]
vol_types = ['Garch', 'EGarch']

for p in p_values:
    for q in q_values:
        for vol in vol_types:
            try:
                model = arch_model(train, vol=vol, p=p, q=q)
                model_result = model.fit(disp='off')

                aic = model_result.aic
                bic = model_result.bic

                rolling_predictions = []
                history = [x for x in train]
                for t in range(len(test)):
                    model = arch_model(history, vol=vol, p=p, q=q)
                    model_fit = model.fit(disp='off')
                    yhat = model_fit.forecast(horizon=1).variance.values[-1,:][0]
                    rolling_predictions.append(yhat)
                    history.append(test[t])

                mae = mean_absolute_error(test, rolling_predictions)

                results.append({
                    'p': p, 'q': q, 'vol': vol,
                    'AIC': aic, 'BIC': bic, 'MAE': mae
                })

                if mae < best_mae:
                    best_aic = aic
                    best_bic = bic
                    best_mae = mae
                    best_params = (p, q, vol)
            except Exception as e:
                print(f"Error fitting model p={p}, q={q}, vol={vol}: {e}")

# best parameters
print(f'Best Model: p={best_params[0]}, q={best_params[1]}, vol={best_params[2]}')
print(f'Best AIC: {best_aic}')
print(f'Best BIC: {best_bic}')
print(f'Best MAE: {best_mae}')

for result in results:
    print(f"p={result['p']}, q={result['q']}, vol={result['vol']}, AIC={result['AIC']}, BIC={result['BIC']}, MAE={result['MAE']}")

#Simulate Geometric Brownian Motion (GBM) for electricity prices
def gbm_simulation(S0, mu, sigma, T=1, dt=1/252):
    N = int(T / dt)
    t = np.linspace(0, T, N)
    W = np.random.standard_normal(size=N)
    W = np.cumsum(W) * np.sqrt(dt)
    X = (mu - 0.5 * sigma**2) * t + sigma * W
    S = S0 * np.exp(X)
    return S

S0 = df['Electricity: Wtd Avg Price $/MWh'].iloc[-1]
mu = np.mean(df['log_return'])
sigma = np.std(df['log_return'])

simulated_prices = gbm_simulation(S0, mu, sigma)
plt.figure(figsize=(10, 6))
plt.plot(simulated_prices)
plt.title('Simulated Electricity Prices Using GBM')
plt.xlabel('Time')
plt.ylabel('Price')
plt.show()

best_model_results = {
    'Best p': best_params[0],
    'Best q': best_params[1],
    'Best vol': best_params[2],
    'Best AIC': best_aic,
    'Best BIC': best_bic,
    'Best MAE': best_mae,
}

# Fit EGARCH(1,1)
Egarch_1_1 = arch_model(df['log_return_scaled'].dropna(), vol='EGarch', p=1, q=1)
Egarch_1_1_result = Egarch_1_1.fit(disp='off')

# Forecasting with EGARCH(1,1)
Egarch_1_1_forecast = Egarch_1_1_result.forecast(horizon=1)

# Fit EGARCH(3,3)
Egarch_3_3 = arch_model(df['log_return_scaled'].dropna(), vol='EGarch', p=3, q=3)
Egarch_3_3_result = Egarch_3_3.fit(disp='off')

# Forecasting with EGARCH(3,3)
Egarch_3_3_forecast = Egarch_3_3_result.forecast(horizon=1)

# Rolling window forecast for EGARCH(1,1)
rolling_predictions_1_1 = []
rolling_predictions_3_3 = []
test_size = int(len(df)*0.2)
train = df['log_return_scaled'].dropna()[:-test_size]
test = df['log_return_scaled'].dropna()[-test_size:]

history = [x for x in train]
for t in range(len(test)):
    model_1_1 = arch_model(history, vol='EGarch', p=1, q=1)
    model_fit_1_1 = model_1_1.fit(disp='off')
    yhat_1_1 = model_fit_1_1.forecast(horizon=1).variance.values[-1,:][0]
    rolling_predictions_1_1.append(yhat_1_1)

    model_3_3 = arch_model(history, vol='EGarch', p=3, q=3)
    model_fit_3_3 = model_3_3.fit(disp='off')
    yhat_3_3 = model_fit_3_3.forecast(horizon=1).variance.values[-1,:][0]
    rolling_predictions_3_3.append(yhat_3_3)

    history.append(test[t])



# Backtesting: calculate MAE and MSE for EGARCH(1,1)
mae_1_1 = mean_absolute_error(test, rolling_predictions_1_1)
mse_1_1 = mean_squared_error(test, rolling_predictions_1_1)


# Backtesting: calculate MAE and MSE for EGARCH(3,3)
mae_3_3 = mean_absolute_error(test, rolling_predictions_3_3)
mse_3_3 = mean_squared_error(test, rolling_predictions_3_3)


# Stochastic Calculus: Simulate Geometric Brownian Motion (GBM) for electricity prices
def gbm_simulation(S0, mu, sigma, T=1, dt=1/252):
    N = int(T / dt)
    t = np.linspace(0, T, N)
    W = np.random.standard_normal(size=N)
    W = np.cumsum(W) * np.sqrt(dt)
    X = (mu - 0.5 * sigma**2) * t + sigma * W
    S = S0 * np.exp(X)
    return S

# Parameters for GBM
S0 = df['Electricity: Wtd Avg Price $/MWh'].iloc[-1]
mu = np.mean(df['log_return'])
sigma = np.std(df['log_return'])

# Simulate 1 year of electricity prices
simulated_prices = gbm_simulation(S0, mu, sigma)

plt.figure(figsize=(10, 6))
plt.plot(test.index, test, label='Actual Returns')
plt.plot(test.index, rolling_predictions_1_1, color='red', label='Predicted Volatility (EGARCH 1,1)')
plt.plot(test.index, rolling_predictions_3_3, color='blue', label='Predicted Volatility (EGARCH 3,3)')
plt.legend()
plt.show()

print(f'Mean Absolute Error (EGARCH 1,1): {mae_1_1}')
print(f'Mean Squared Error (EGARCH 1,1): {mse_1_1}')

print(f'Mean Absolute Error (EGARCH 3,3): {mae_3_3}')
print(f'Mean Squared Error (EGARCH 3,3): {mse_3_3}')

plt.figure(figsize=(10, 6))
plt.plot(simulated_prices)
plt.title('Simulated Electricity Prices Using GBM')
plt.xlabel('Time')
plt.ylabel('Price')
plt.show()

"""###Garch v2:"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from arch import arch_model

# Assuming df is your DataFrame and it has a datetime index

test_size = int(len(df) * 0.2)

results_list = []

# Loop over GARCH parameters
p_values = [1, 2, 3]
q_values = [1, 2, 3]
vol_types = ['Garch', 'EGarch']

for p in p_values:
    for q in q_values:
        for vol in vol_types:
            try:
                # Split data into training and validation sets
                train_data = df[:-test_size]
                test_data = df[-test_size:]

                predictions = []

                for t in range(len(test_data)):
                    model = arch_model(train_data, vol=vol, p=p, q=q)
                    results = model.fit(disp='off')

                    # Forecast the next day
                    forecast = results.forecast(horizon=1)
                    predicted_value = forecast.mean.iloc[-1, 0]

                    predictions.append(predicted_value)

                    # Update training data with the new observed value
                    train_data = pd.concat([train_data, test_data.iloc[t:t+1]])

                actual_values = test_data.values
                # Calculate RMSE
                rmse = np.sqrt(np.mean((np.array(predictions) - actual_values) ** 2))

                # Calculate MAE
                mae = np.mean(np.abs(np.array(predictions) - actual_values))

                results_list.append((p, q, vol, results.aic, rmse, mae))

            except Exception as e:
                print(f"Error with parameters p={p}, q={q}, vol={vol}: {e}")
                results_list.append((p, q, vol, None, None, None, str(e)))

# Display results
for result in results_list:
    print(result)

results_list

# Convert the results to a DataFrame for better readability
results_df = pd.DataFrame(results_list, columns=['p', 'q', 'vol', 'AIC', 'RMSE', 'MAE'])

# Display the results
print(results_df.sort_values(by='AIC'))
print(results_df.sort_values(by='RMSE'))

# Applying the best found model
last_n_days = df.index[-test_size:]

best_model_params = results_df.sort_values(by='AIC').iloc[0]

p_best, q_best, vol_best = best_model_params['p'], best_model_params['q'], best_model_params['vol']

try:
    train_data = df[:-test_size]
    test_data = df[-test_size:]

    predictions = []
    lower_limits = []
    upper_limits = []

    for t in range(len(test_data)):
        model = arch_model(train_data, vol=vol_best, p=p_best, q=q_best)
        results = model.fit(disp='off')

        # Forecast the next day
        forecast = results.forecast(horizon=1)
        predicted_value = forecast.mean.iloc[-1, 0]
        predictions.append(predicted_value)

        # Get confidence intervals of predictions
        conf_int = forecast.variance.iloc[-1, 0]
        lower_limits.append(predicted_value - 1.96 * np.sqrt(conf_int))
        upper_limits.append(predicted_value + 1.96 * np.sqrt(conf_int))

        # Update training data with the new observed value
        train_data = pd.concat([train_data, test_data.iloc[t:t+1]])

    # Convert predictions to a pandas Series
    predictions_series = pd.Series(predictions, index=test_data.index)
    lower_limits_series = pd.Series(lower_limits, index=test_data.index)
    upper_limits_series = pd.Series(upper_limits, index=test_data.index)

    # Plot the last n days of df data
    plt.plot(last_n_days, df.loc[last_n_days], label='observed')

    # Plot the predictions for the test period
    plt.plot(predictions_series.index, predictions_series, color='r', label='forecast')

    # Shade the area between your confidence limits for the test period
    plt.fill_between(predictions_series.index, lower_limits_series, upper_limits_series, color='pink')

    # Set labels, legends, and show plot
    plt.xlabel('Date')
    plt.ylabel(f'Electricity Price - USD for p:{p_best}, q:{q_best}, vol:{vol_best}')
    plt.legend()
    plt.title(f'GARCH ({p_best}, {q_best}, {vol_best}) Forecast and Confidence Intervals')
    plt.show()

except Exception as e:
    print(f'GARCH ({p_best}, {q_best}, {vol_best}) encountered an error: {str(e)}')

predictions_series = pd.Series(predictions, index=test_data.index)
lower_limits_series = pd.Series(lower_limits, index=test_data.index)
upper_limits_series = pd.Series(upper_limits, index=test_data.index)

# Create trading signals based on the predictions
data = pd.DataFrame({
     'X_test': test_data.squeeze().shift(1),
     'y_test': test_data.squeeze(),
     'predictions': predictions_series,
})

    # Initialize the 'position' column
data['position'] = 0

    # Generate trading signals
for i in range(len(data)):
    if data['predictions'].iloc[i] > data['X_test'].iloc[i]:
        data['position'].iloc[i] = 1  # Buy signal
    elif data['predictions'].iloc[i] < data['X_test'].iloc[i]:
        data['position'].iloc[i] = -1  # Sell signal
    else:
        data['position'].iloc[i] = 0  # No action
 # Initialize the 'returns' and 'correct' columns
data['returns'] = np.nan
data['correct'] = np.nan

    # Calculate returns and correctness
for i in range(1, len(data)):
    if data['position'].iloc[i-1] == 1:  # Long position
        if data['X_test'].iloc[i] > data['X_test'].iloc[i-1]:  # Market went up
            data['correct'].iloc[i] = 1
        else:
            data['correct'].iloc[i] = 0
    elif data['position'].iloc[i-1] == -1:  # Short position
        if data['X_test'].iloc[i] < data['X_test'].iloc[i-1]:  # Market went down
            data['correct'].iloc[i] = 1
        else:
            data['correct'].iloc[i] = 0
        # Calculate returns
    if data['position'].iloc[i-1] == 1:
        data['returns'].iloc[i] = (data['X_test'].iloc[i] - data['X_test'].iloc[i-1]) / data['X_test'].iloc[i-1]
    elif data['position'].iloc[i-1] == -1:
        data['returns'].iloc[i] = (data['X_test'].iloc[i-1] - data['X_test'].iloc[i]) / data['X_test'].iloc[i-1]

    # Drop NaN values
data.dropna(inplace=True)

    # Calculate performance metrics
winrate = len(data[data['correct'] == 1]) / len(data) * 100
roi = data['returns'].sum() * 100

# Print results
print(f'Winrate for GARCH model: {winrate}%')
print(f'Return on Investment (ROI) for GARCH model: {roi}%')
# Plot returns
plt.figure(figsize=(14, 7))
plt.plot(data['returns'].iloc[0:500], label='Returns', color='blue')
plt.plot(data['returns'].iloc[0:500].cumsum(), label='Cumulative Returns', color='green')
plt.legend()
plt.title('Trading Returns and Cumulative Returns')
plt.xlabel('Date')
plt.ylabel('Returns')
plt.show()

"""##deep learning models:"""

import tensorflow as tf
from tensorflow.keras.models import Sequential
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error

"""###GRU"""

#pip install keras-tuner

from tensorflow.keras.layers import Dense, GRU

from keras_tuner import RandomSearch

# Set seed for reproducibility
tf.random.set_seed(7)

# Split into train and test sets
train_size = int(len(df) * 0.8)
train, test = df[:train_size], df[train_size:]

# Normalize the datasets
scaler = MinMaxScaler(feature_range=(0, 1))
train = scaler.fit_transform(train)
test = scaler.transform(test)

X_train, y_train = train[:-1], train[1:]
X_test, y_test = test[:-1], test[1:]

# Reshape input to be [samples, time steps, features]
X_train = np.reshape(X_train, (X_train.shape[0], 1, X_train.shape[1]))
X_test = np.reshape(X_test, (X_test.shape[0], 1, X_test.shape[1]))

# Define the model-building function
def build_model(hp):
    model = Sequential()
    model.add(GRU(units=hp.Int('units', min_value=32, max_value=256, step=32), input_shape=(1, X_train.shape[2])))
    model.add(Dense(1))
    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=hp.Choice('learning_rate', values=[1e-2, 1e-3, 1e-4])), loss='mean_squared_error')
    return model

# Set up the Random Search tuner
tuner = RandomSearch(
    build_model,
    objective='val_loss',
    max_trials=10,  # Number of hyperparameter combinations to try
    executions_per_trial=2,  # Number of models to train per trial
    directory='hyperparameter_tuning',
    project_name='gru_model'
)

# Run the hyperparameter search
tuner.search(X_train, y_train, epochs=100, validation_split=0.2, batch_size=32)

# Retrieve the best model
best_model = tuner.get_best_models(num_models=1)[0]

# Evaluate the best model on the test set
predictions = best_model.predict(X_test)
mse = mean_squared_error(y_test, predictions)
print("Mean Squared Error of the best model:", mse)

# Print the best hyperparameters
best_hyperparameters = tuner.get_best_hyperparameters(num_trials=1)[0]
print("Best hyperparameters:")
print(best_hyperparameters)

rmse = np.sqrt(mean_squared_error(y_test, predictions))
print("Root Mean Squared Error of the best model:", rmse) #0.021245611639912846

from sklearn.metrics import mean_squared_error

# Generate predictions from the best model
predictions = best_model.predict(X_test)

# Calculate the mean squared error to get an idea of the confidence interval
mse = mean_squared_error(y_test, predictions)
std_dev = np.sqrt(mse)

# Calculate the upper and lower bounds of the confidence interval
confidence_interval_upper = predictions + 1.96 * std_dev
confidence_interval_lower = predictions - 1.96 * std_dev

# Plotting
plt.figure(figsize=(14, 8))

# Plot the actual values
plt.plot(range(len(y_test)), y_test, color='blue', label='Actual')

# Plot the predictions
plt.plot(range(len(predictions)), predictions, color='red', label='Predicted')

# Fill the confidence interval
plt.fill_between(range(len(predictions)), confidence_interval_lower.flatten(), confidence_interval_upper.flatten(), color='pink', alpha=0.5, label='Confidence Interval')

# Add labels and legend
plt.xlabel('Time Steps')
plt.ylabel('Normalized Price')
plt.title('Electricity Prices: Actual vs Predicted with Confidence Interval')
plt.legend()

# Show the plot
plt.show()

"""####Trading ALGO:"""

# Reshape X_test and y_test to be 1-dimensional
X_test_flat = X_test.flatten()
y_test_flat = y_test.flatten()
predictions_flat = predictions.flatten()

# Create the DataFrame with the flattened arrays
data = pd.DataFrame({'X_test': X_test_flat, 'y_test': y_test_flat, 'predictions': predictions_flat})

data

data['position'] = 0
for i in range(len(data)):
    if data['X_test'][i] < data['predictions'][i]:
      data['position'][i] = 1
    elif data['X_test'][i] > data['predictions'][i]:
      data['position'][i] = -1
    else:
      data['position'][i] = 0

data

# Initialize the 'returns' and 'correct' columns
data['returns'] = None
data['correct'] = None

# Main loop to calculate 'correct' values
for i in range(len(data)):
    row_index = data.index[i]  # Get the actual index label for the current row

    if data['position'][row_index] == 1:  # Long position
        if data['X_test'][row_index] < data['y_test'][row_index]:  # Market went up
            if data['y_test'][row_index] > data['predictions'][row_index]:
                data.at[row_index, 'correct'] = 1  # Prediction lower than actual
            else:
                data.at[row_index, 'correct'] = 0  # Prediction higher than actual
        else:
            data.at[row_index, 'correct'] = -1  # Market went down, wrong position

    elif data['position'][row_index] == -1:  # Short position
        if data['X_test'][row_index] > data['y_test'][row_index]:  # Market went down
            if data['y_test'][row_index] < data['predictions'][row_index]:
                data.at[row_index, 'correct'] = 1  # Prediction higher than actual
            else:
                data.at[row_index, 'correct'] = 0  # Prediction lower than actual
        else:
            data.at[row_index, 'correct'] = -1  # Market went up, wrong position

# Iterate over the actual index of the DataFrame for returns calculation
for index in data.index:
    if data.loc[index, 'correct'] == 1:
        data.loc[index, 'returns'] = abs((data.loc[index, 'predictions'] - data.loc[index, 'X_test']) / data.loc[index, 'X_test'])
    elif data.loc[index, 'correct'] == 0:
        data.loc[index, 'returns'] = abs((data.loc[index, 'y_test'] - data.loc[index, 'X_test']) / data.loc[index, 'X_test'])
    elif data.loc[index, 'correct'] == -1:
        data.loc[index, 'returns'] = abs((data.loc[index, 'y_test'] - data.loc[index, 'X_test']) / data.loc[index, 'X_test']) * (-1)

data

print(f'winrate for GRU is: {len(data[data["correct"]==1])/int(len(data))*100}%')

print(f'the ROI for GRU is: {data["returns"].sum()*100}%')

plt.plot(data['returns'].iloc[0:500], label='Returns') # Add label for returns
plt.plot(data['y_test'].iloc[0:500], label='y_test') # Add label for y_test
plt.plot(data['returns'].iloc[0:500].cumsum(), label='Cumulative Returns') # Add label for cumulative returns
plt.legend() # Display the legend
plt.show()

"""#### Trading part:"""

# Detect trend in predictions
def detect_trend(data, column_name):
    data['Price Change'] = data[column_name].pct_change()
    data['Trend'] = np.where(data['Price Change'] > 0, 1, -1)
    data['Trend'] = data['Trend'].replace(0, np.nan).ffill().fillna(0)
    return data

# Generate buy/sell signals based on predicted trend changes
def generate_trend_signals(predictions):
    data = pd.DataFrame(predictions, columns=['Predicted'])
    data = detect_trend(data, 'Predicted')

    signals = np.zeros(len(data))
    for i in range(1, len(data)):
        if data['Trend'].iloc[i] == 1 and data['Trend'].iloc[i - 1] == -1:  # Uptrend detected
            signals[i] = 1  # Buy signal
        elif data['Trend'].iloc[i] == -1 and data['Trend'].iloc[i - 1] == 1:  # Downtrend detected
            signals[i] = -1  # Sell signal
    return signals

# Implement trading strategy
def trading_strategy(data, predictions, initial_capital=10000, amount_per_trade=1000):
    capital = initial_capital
    holdings = 0
    buy_price = 0

    # Align signals with data indices
    signals = generate_trend_signals(predictions)
    data = data.iloc[-len(signals):].copy()  # Truncate data to match the signals

    for i in range(len(data)):
        if signals[i] == 1:  # Buy signal
            if capital >= amount_per_trade:
                buy_price = data['Electricity: Wtd Avg Price $/MWh'].iloc[i]
                holdings += amount_per_trade / buy_price
                capital -= amount_per_trade
                #print(f"Buy at {buy_price:.2f}, Holdings: {holdings:.2f}, Capital: {capital:.2f}")

        elif signals[i] == -1:  # Sell signal
            if holdings > 0:
                sell_price = data['Electricity: Wtd Avg Price $/MWh'].iloc[i]
                capital += holdings * sell_price
                holdings = 0
                #print(f"Sell at {sell_price:.2f}, Holdings: {holdings:.2f}, Capital: {capital:.2f}")

    final_capital = capital + holdings * data['Electricity: Wtd Avg Price $/MWh'].iloc[-1]
    return final_capital

# Assuming 'predictions' and 'y_test' are defined elsewhere and match the size of your test data
# Run the strategy
final_capital = trading_strategy(df, predictions)
print(f"Final capital: {final_capital:.2f}")

# Evaluate strategy performance
df_signals = pd.DataFrame(index=df.index[-len(predictions):], columns=['Actual', 'Predicted', 'Signal'])
df_signals['Actual'] = df['Electricity: Wtd Avg Price $/MWh'].iloc[-len(predictions):].values
df_signals['Predicted'] = predictions.flatten()
df_signals['Signal'] = generate_trend_signals(predictions)
df_signals['Return'] = df_signals['Actual'].pct_change()
df_signals['Strategy Return'] = df_signals['Return'] * df_signals['Signal'].shift(1)

# Calculate cumulative returns
df_signals['Cumulative Market Return'] = (1 + df_signals['Return']).cumprod()
df_signals['Cumulative Strategy Return'] = (1 + df_signals['Strategy Return']).cumprod()

# Plot the cumulative returns with logarithmic scale
plt.figure(figsize=(14, 8))
plt.semilogy(df_signals['Cumulative Market Return'], label='Market Return')
plt.semilogy(df_signals['Cumulative Strategy Return'], label='Strategy Return')
plt.xlabel('Time')
plt.ylabel('Cumulative Return')
plt.title('Market Return vs Strategy Return (Logarithmic Scale)')
plt.legend()
plt.show()

# Evaluate strategy performance
total_return = df_signals['Cumulative Strategy Return'].iloc[-1] - 1
sharpe_ratio = df_signals['Strategy Return'].mean() / df_signals['Strategy Return'].std() * np.sqrt(252)  # Assuming daily returns
max_drawdown = df_signals['Cumulative Strategy Return'].cummax() - df_signals['Cumulative Strategy Return'].cummin()

print("Total Return: {:.2f}%".format(total_return * 100))
print("Sharpe Ratio: {:.2f}".format(sharpe_ratio))
print("Max Drawdown: {:.2f}%".format(max_drawdown.max() * 100))

df_signals

data.shape

initial_investment = 100000
current_balance = initial_investment

entry_price = None
i=0
returns = []
for index, row in data.iterrows():
    price = row['Electricity: Wtd Avg Price $/MWh']
    position = row['Position']

    if position == 1 and entry_price is None:
        entry_price = price
        #print(price)

    if position != 1 and entry_price is not None:
        roi = (price - entry_price) / entry_price
        returns.append(roi)
        current_balance += current_balance * roi

        entry_price = None

total_roi = (current_balance - initial_investment) / initial_investment * 100

print(f"Total ROI: {total_roi}%")
print(f"Final Balance: ${current_balance}")


#something not correct here

returns=pd.DataFrame(returns,columns=['returns'])
returns.shape

returns = pd.DataFrame(returns,columns=['returns'])
returns=(returns + 1).cumprod() -1

returns['returns']

data.tail()

# Define the range to zoom in (e.g., from index 0 to 19 for this example)
start_idx = 250
end_idx = 1000

# Initialize the plot
plt.figure(figsize=(15, 7))

# Plot the prices, using green for long positions and red for short positions
for i in range(start_idx + 1, end_idx + 1):
    if data['Position'][i] == 1:
        plt.plot([i-1, i], [data['Electricity: Wtd Avg Price $/MWh'][i-1], data['Electricity: Wtd Avg Price $/MWh'][i]], color='green')
    elif data['Position'][i] == -1:
        plt.plot([i-1, i], [data['Electricity: Wtd Avg Price $/MWh'][i-1], data['Electricity: Wtd Avg Price $/MWh'][i]], color='red')

# Add titles and labels
plt.title('Price Plot with Position Indicator (Zoomed In)')
plt.xlabel('Time')
plt.ylabel('Price')

# Show the plot
plt.show()

buy_price = None
total_return = 0.0

for i in range(1, len(data)):
    if data['Position'].iloc[i] == 1 and data['Position'].iloc[i - 1] == -1:
        buy_price = data['Electricity: Wtd Avg Price $/MWh'].iloc[i]
    elif data['Position'].iloc[i] == -1 and data['Position'].iloc[i - 1] == 1:
        if buy_price is not None:
            sell_price = data['Electricity: Wtd Avg Price $/MWh'].iloc[i]
            total_return += (sell_price - buy_price) / buy_price
            buy_price = None

# Print the total return
print(f'Total Return: {total_return:.2%}')

"""###LSTM"""

from keras.layers import LSTM, Dense

"""####Best activation function:"""

from tensorflow.keras.layers import Activation, LeakyReLU
from tensorflow.keras.optimizers import Adam

# normalize the dataset
scaler = MinMaxScaler(feature_range=(0, 1))

plt.plot(df)

train_size=int(len(df)*0.8)
train=df[:train_size]
test=df[train_size:]
print(len(train),len(test))

train = scaler.fit_transform(train)
test = scaler.transform(test)

X_train = train[:-1]
y_train = train[1:]

X_test = test[:-1]
y_test = test[1:]

print(X_train)
print(y_train)

# X_train = scaler.fit_transform(X_train)
# X_test = scaler.fit_transform(X_test)
# y_train = scaler.fit_transform(y_train)
# y_test = scaler.fit_transform(y_test)

# reshape input to be [samples, time steps, features]
X_train = np.reshape(X_train, (X_train.shape[0], 1, X_train.shape[1]))
X_test = np.reshape(X_test, (X_test.shape[0], 1, X_test.shape[1]))

print(X_train.shape)

# Define a function to calculate RMSE
def calculate_rmse(y_true, y_pred):
    return np.sqrt(np.mean((y_true - y_pred) ** 2))

# Define your get_model function
def get_model(activation_function):
    model = Sequential()
    model.add(LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])))
    model.add(Activation(activation_function))
    model.add(LSTM(50))
    model.add(Activation(activation_function))
    model.add(Dense(1))
    model.compile(optimizer=Adam(), loss='mean_squared_error')
    return model

# List of activation functions to try
activations = ['relu', 'leaky_relu', 'sigmoid', 'tanh']
activation_results = {}

# Loop over each activation function
for act in activations:
    # Get a new model with the current activation function
    model = get_model(act)
    # Fit the model and store the history results
    history = model.fit(X_train, y_train, verbose=0, epochs=25, validation_data=(X_test, y_test))
    activation_results[act] = history

# Dictionary to store RMSE values for each activation function
rmse_per_function = {}

# Calculate RMSE for each activation function
for act, history in activation_results.items():
    # Predict using the model
    y_pred = model.predict(X_test)
    # Calculate RMSE
    rmse = calculate_rmse(y_test, y_pred)
    rmse_per_function[act] = rmse

# Print RMSE for tanh activation function
print(f"RMSE for tanh activation function: {rmse_per_function['tanh']}")

# Plot validation loss
val_loss_per_function = {act: history.history['val_loss'] for act, history in activation_results.items()}
val_loss = pd.DataFrame(val_loss_per_function)
if not val_loss.empty:
    val_loss.plot()
    plt.title('Validation Loss per Activation Function')
    plt.xlabel('Epochs')
    plt.ylabel('Validation Loss')
    plt.legend(title='Activation Functions')
    plt.show()
else:
    print("No validation loss data to plot.")

# Plot validation loss
val_loss_per_function = {act: history.history['val_loss'] for act, history in activation_results.items()}
val_loss = pd.DataFrame(val_loss_per_function)

if not val_loss.empty:
    # Slice to get only the last 5 points
    last_5_points = val_loss.tail(5)

    # Plot the last 5 points
    last_5_points.plot()
    plt.title('Validation Loss per Activation Function (Last 5 Epochs)')
    plt.xlabel('Epochs')
    plt.ylabel('Validation Loss')
    plt.legend(title='Activation Functions')
    plt.show()
else:
    print("No validation loss data to plot.")

"""![image_2024-07-14_154917900.png](data:image/png;base64,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)"""

# Select the best activation function based on RMSE
best_activation = min(rmse_per_function, key=rmse_per_function.get)
print(f"Best activation function: {best_activation}")

# Train the model with the best activation function
best_model = get_model(best_activation)
best_model.fit(X_train, y_train, verbose=0, epochs=100, validation_data=(X_test, y_test))

# Make predictions
y_pred = best_model.predict(X_test)

# Inverse transform the predictions and actual values
y_pred_inverse = scaler.inverse_transform(y_pred)
y_test_inverse = scaler.inverse_transform(y_test)

# Plot actual vs predicted values
plt.figure(figsize=(14, 5))
plt.plot(y_test_inverse, label='Actual', color='blue')
plt.plot(y_pred_inverse, label='Predicted', color='red')
plt.title('Actual vs Predicted Prices')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

# Calculate and print the RMSE for the best model
best_rmse = calculate_rmse(y_test_inverse, y_pred_inverse)
print(f"Best RMSE: {best_rmse}")

"""####LSTM using prices instead of normalized prices:"""

# Check the length of your DataFrame
print("Length of DataFrame:", len(df))

sequence_length = 14

# Split the data into training and testing sets
train_size = int(len(df) * 0.8)
train_data, test_data = df[:train_size], df[train_size:]

def create_sequences(df, sequence_length):
    X, y = [], []
    for i in range(len(df) - sequence_length):
        X.append(df[i:i+sequence_length].values)  # Convert to numpy array
        y.append(df.iloc[i+sequence_length].values)  # Select the next value as target
    return np.array(X), np.array(y)

# Adjust sequence length if necessary
sequence_length = min(sequence_length, len(df) - 1)

# Call create_sequences function
X_train, y_train = create_sequences(train_data, sequence_length)
X_test, y_test = create_sequences(test_data, sequence_length)

# Build the LSTM model
model = Sequential()
model.add(LSTM(units=4, input_shape=(sequence_length, 1))) #this was 64 before which resulted in 9.313065967344976 RMSE
model.add(Dense(units=1))
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, epochs=100, batch_size=32)

# Predict on the test set
predictions = model.predict(X_test)

# Evaluate the model
mse = np.mean((predictions - y_test) ** 2)
print("Mean Squared Error:", mse)

rmse = np.sqrt(mean_squared_error(y_test, predictions))
print(rmse) #9.313065967344976

"""####LSTM Regression:"""

# Convert an array of values into a dataset matrix
def create_dataset(dataset, look_back=1):
    dataX, dataY = [], []
    for i in range(len(dataset)-look_back-1):
        a = dataset[i:(i+look_back), 0]
        dataX.append(a)
        dataY.append(dataset[i + look_back, 0])
    return np.array(dataX), np.array(dataY)

# Fix random seed for reproducibility
tf.random.set_seed(7)

# Load and preprocess the data
dataset = pd.DataFrame(df)

# Split into train and test sets
train_size = int(len(dataset) * 0.8)
test_size = len(dataset) - train_size
train, test = dataset.iloc[0:train_size], dataset.iloc[train_size:len(dataset)]

# Normalize the datasets (after spliting the dataset)
scaler = MinMaxScaler(feature_range=(0, 1))
train = scaler.fit_transform(train)
test = scaler.transform(test)

# Reshape into X=t and Y=t+1
look_back = 14
trainX, trainY = create_dataset(train, look_back)
testX, testY = create_dataset(test, look_back)

# Reshape input to be [samples, time steps, features]
trainX = np.reshape(trainX, (trainX.shape[0], trainX.shape[1], 1))
testX = np.reshape(testX, (testX.shape[0], testX.shape[1], 1))

# Create and fit the LSTM network
model = Sequential()
model.add(LSTM(4, input_shape=(look_back, 1)))
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer='adam')
model.fit(trainX, trainY, epochs=100, batch_size=1, verbose=2)

# Make predictions
trainPredict = model.predict(trainX)
testPredict = model.predict(testX)

# Invert predictions
trainPredict = scaler.inverse_transform(trainPredict)
trainY = scaler.inverse_transform([trainY])
testPredict = scaler.inverse_transform(testPredict)
testY = scaler.inverse_transform([testY])

# Calculate root mean squared error
trainScore = np.sqrt(mean_squared_error(trainY[0], trainPredict[:,0]))
print('Train Score: %.2f RMSE' % (trainScore))
testScore = np.sqrt(mean_squared_error(testY[0], testPredict[:,0]))
print('Test Score: %.2f RMSE' % (testScore))

"""![image_2024-07-04_132300120.png](data:image/png;base64,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)

Train Score: 11.89 RMSE
Test Score: 9.28 RMSE
"""

# Shift train predictions for plotting
trainPredictPlot = np.empty_like(dataset)
trainPredictPlot[:, :] = np.nan
trainPredictPlot[look_back:len(trainPredict)+look_back, 0] = trainPredict[:,0]

# Shift test predictions for plotting
testPredictPlot = np.empty_like(dataset)
testPredictPlot[:, :] = np.nan
testPredictPlot[len(trainPredict)+(look_back*2)+1:len(dataset)-1, 0] = testPredict[:,0]

# Plot baseline and predictions
plt.plot(scaler.inverse_transform(dataset))
plt.plot(trainPredictPlot)
plt.plot(testPredictPlot)
plt.show()

plt.plot(trainPredictPlot)
plt.plot(testPredictPlot)
plt.show()

"""#Day trading technics:

##BOS trading:
"""

import pandas as pd
import numpy as np

# Function to detect trend
def detect_trend(data, extrems_date, trend, close_readfiles):
    latest_close = data.iloc[-1]
    if trend and latest_close < close_readfiles:
        trend = False
        data = data[data.index >= extrems_date]
    elif not trend and latest_close > close_readfiles:
        trend = True
        data = data[data.index >= extrems_date]
    return trend, data

# Function to get latest high, low, and close
def get_latest_high_and_low(data, start_date, extrems_date, initial_trend, new_trend, high, low, close):
    if initial_trend and not new_trend:
        low = np.inf
        close = np.inf
        high = None
        start_date = extrems_date
    elif not initial_trend and new_trend:
        high = -np.inf
        close = -np.inf
        low = None
        start_date = extrems_date

    if new_trend:
        for i in range(len(data)):
            if high <= data.iloc[i]:
                high = data.iloc[i]
                extrems_date = data.index[i]
                temp = i
        for temp in range(temp, -1, -1):
            if close == data.iloc[temp]:
                break
            if data.iloc[temp - 1] > data.iloc[temp] and data.iloc[temp + 1] > data.iloc[temp]:
                close = data.iloc[temp]
                break
    else:
        for i in range(len(data)):
            if low >= data.iloc[i]:
                low = data.iloc[i]
                extrems_date = data.index[i]
                temp = i
        for temp in range(temp, -1, -1):
            if close == data.iloc[temp]:
                break
            if data.iloc[temp - 1] < data.iloc[temp] and data.iloc[temp + 1] < data.iloc[temp]:
                close = data.iloc[temp]
                break

    if close in [None, np.inf, -np.inf]:
        close = data.iloc[0]

    return high, low, close, start_date, extrems_date

# Function to simulate trading and calculate final capital
def backtest_with_capital(df, initial_capital=100000):
    # Initialize parameters
    trend = True  # Assume an initial trend
    high = -np.inf
    low = np.inf
    close = df.iloc[0, 0]
    extrems_date = df.index[0]
    start_date = df.index[0]
    capital = initial_capital
    position = None

    results = []

    # Iterate through the data
    for current_date, current_row in df.iterrows():
        current_price = current_row['Electricity: Wtd Avg Price $/MWh']
        data_up_to_current_date = df.loc[:current_date, 'Electricity: Wtd Avg Price $/MWh']

        # Detect trend
        new_trend, relevant_data = detect_trend(data_up_to_current_date, extrems_date, trend, close)

        # Get latest high, low, and close
        high, low, close, start_date, extrems_date = get_latest_high_and_low(relevant_data, start_date, extrems_date, trend, new_trend, high, low, close)

        # Strategy: Buy or sell based on trend change (simulated)
        if position is None:
            if new_trend:
                position = 'long'
            else:
                position = 'short'
        elif new_trend and position == 'short':
            capital += current_price * 100  # Example: Buying 100 units of electricity at current price
            position = 'long'
        elif not new_trend and position == 'long':
            capital -= current_price * 100  # Example: Selling 100 units of electricity at current price
            position = 'short'

        # Store results for analysis
        results.append((current_date, current_price, trend, new_trend, high, low, close, capital, position))

        # Update trend
        trend = new_trend

    # Create a DataFrame to analyze results
    results_df = pd.DataFrame(results, columns=['Date', 'Price', 'Initial Trend', 'New Trend', 'High', 'Low', 'Close', 'Capital', 'Position'])
    return results_df

# Run backtest with initial capital of $100,000
results_df = backtest_with_capital(df, initial_capital=100000)

results_df

buy_price = None
total_return = 0.0

for i in range(1, len(results_df)):
    if results_df['Position'].iloc[i] == 'long' and results_df['Position'].iloc[i - 1] == 'short':
        buy_price = results_df['Price'].iloc[i]
    elif results_df['Position'].iloc[i] == 'short' and results_df['Position'].iloc[i - 1] == 'long':
        if buy_price is not None:
            sell_price = results_df['Price'].iloc[i]
            total_return += (sell_price - buy_price) / buy_price
            buy_price = None

# Print the total return
print(f'Total Return: {total_return:.2%}')

initial_investment = 100000
current_balance = initial_investment

entry_price = None
returns = []

for index, row in results_df.iterrows():
    price = row['Price']
    position = row['Position']

    if position == 'long' and entry_price is None:
        entry_price = price

    if position != 'long' and entry_price is not None:
        roi = (price - entry_price) / entry_price
        returns.append(roi)
        current_balance += current_balance * roi

        entry_price = None

total_roi = (current_balance - initial_investment) / initial_investment * 100

print(f"Total ROI: {total_roi:.2f}%")
print(f"Final Balance: ${current_balance:.2f}")

returns=pd.DataFrame(returns,columns=['returns'])

returns

returns2=(returns + 1).cumprod() -1

returns2

# Define the range to zoom in (e.g., from index 0 to 19 for this example)
start_idx = 250
end_idx = 500

# Initialize the plot
plt.figure(figsize=(15, 7))

# Plot the prices, using green for long positions and red for short positions
for i in range(start_idx + 1, end_idx + 1):
    if results_df['Position'][i] == 'long':
        plt.plot([i-1, i], [results_df['Price'][i-1], results_df['Price'][i]], color='green')
    else:
        plt.plot([i-1, i], [results_df['Price'][i-1], results_df['Price'][i]], color='red')

# Add titles and labels
plt.title('Price Plot with Position Indicator (Zoomed In)')
plt.xlabel('Time')
plt.ylabel('Price')

# Show the plot
plt.show()
plt.figure(figsize=(15, 7))
returns['returns'].iloc[start_idx:end_idx].plot()

"""##Percentile strategy (mean reversion):"""

data = pd.DataFrame(df)

# Define the moving window size
window_size = 20

# Function to calculate percentiles
def calculate_percentiles(data, window_size):
    data['Percentile_20'] = data['Electricity: Wtd Avg Price $/MWh'].rolling(window=window_size).apply(lambda x: np.percentile(x, 20), raw=True)
    data['Percentile_80'] = data['Electricity: Wtd Avg Price $/MWh'].rolling(window=window_size).apply(lambda x: np.percentile(x, 80), raw=True)
    return data

# Apply the percentile calculation
data = calculate_percentiles(data, window_size)

# Initialize columns for signals and positions
data['Signal']=0
data['Position']=0

# Generate trading signals
for i in range(window_size, len(data)):
    if data['Electricity: Wtd Avg Price $/MWh'].iloc[i] <= data['Percentile_20'].iloc[i]:
        data['Signal'].iloc[i] = 1  # Buy signal
    elif data['Electricity: Wtd Avg Price $/MWh'].iloc[i] >= data['Percentile_80'].iloc[i]:
        data['Signal'].iloc[i] = -1  # Sell signal

# Convert signals to positions
data['Position'] = data['Signal'].replace(to_replace=0, method='ffill')  # Hold the position until a new signal

# Replace NaN values (if any) with 0
data.fillna(method='ffill', inplace=True)

initial_investment = 100000
current_balance = initial_investment

entry_price = None
i=0
returns = []
for index, row in data.iterrows():
    price = row['Electricity: Wtd Avg Price $/MWh']
    position = row['Position']

    if position == 1 and entry_price is None:
        entry_price = price
        #print(price)

    if position != 1 and entry_price is not None:
        roi = (price - entry_price) / entry_price
        returns.append(roi)
        current_balance += current_balance * roi

        entry_price = None

total_roi = (current_balance - initial_investment) / initial_investment * 100

print(f"Total ROI: {total_roi}%")
print(f"Final Balance: ${current_balance}")


#something not correct here

returns=pd.DataFrame(returns,columns=['returns'])
returns.shape

returns = pd.DataFrame(returns,columns=['returns'])
returns=(returns + 1).cumprod() -1

returns['returns']

data.tail()

import pandas as pd
import matplotlib.pyplot as plt


# Define the range to zoom in (e.g., from index 0 to 19 for this example)
start_idx = 250
end_idx = 1000

# Initialize the plot
plt.figure(figsize=(15, 7))

# Plot the prices, using green for long positions and red for short positions
for i in range(start_idx + 1, end_idx + 1):
    if data['Position'][i] == 1:
        plt.plot([i-1, i], [data['Electricity: Wtd Avg Price $/MWh'][i-1], data['Electricity: Wtd Avg Price $/MWh'][i]], color='green')
    elif data['Position'][i] == -1:
        plt.plot([i-1, i], [data['Electricity: Wtd Avg Price $/MWh'][i-1], data['Electricity: Wtd Avg Price $/MWh'][i]], color='red')

# Add titles and labels
plt.title('Price Plot with Position Indicator (Zoomed In)')
plt.xlabel('Time')
plt.ylabel('Price')

# Show the plot
plt.show()

buy_price = None
total_return = 0.0

for i in range(1, len(data)):
    if data['Position'].iloc[i] == 1 and data['Position'].iloc[i - 1] == -1:
        buy_price = data['Electricity: Wtd Avg Price $/MWh'].iloc[i]
    elif data['Position'].iloc[i] == -1 and data['Position'].iloc[i - 1] == 1:
        if buy_price is not None:
            sell_price = data['Electricity: Wtd Avg Price $/MWh'].iloc[i]
            total_return += (sell_price - buy_price) / buy_price
            buy_price = None

# Print the total return
print(f'Total Return: {total_return:.2%}')